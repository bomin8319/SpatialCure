library(devtools)
document()
check()
document()
check()
document()
check()
install()
library(devtools)
document()
check()
X = sample(1:10, 1000, TRUE)
X
Z = X
X = sample(1:100, 1000, TRUE)
p1 = dim(X)[2]#
  p2 = dim(Z)[2]#
  # initial values#
  betas = rep(0, p1)#
  gammas = rep(0, p2)#
  rho = 1#
  lambda = 1#
  W = rep(0, length(Y))#
  V = rep(0, length(Y))#
  delta = 1 / (1 + exp(-Z %*% gammas + V))#
  Sigma.b = 10 * p1 * diag(p1)#
  Sigma.g = 10 * p2 * diag(p2)#
  betas.samp = matrix(NA, nrow = (N - burn) / thin, ncol = p1)#
  gammas.samp = matrix(NA, nrow = (N - burn) / thin, ncol = p2)#
  rho.samp = rep(NA, (N - burn) / thin)
N = 1000
p1 = dim(X)[2]#
  p2 = dim(Z)[2]#
  # initial values#
  betas = rep(0, p1)#
  gammas = rep(0, p2)#
  rho = 1#
  lambda = 1#
  W = rep(0, length(Y))#
  V = rep(0, length(Y))#
  delta = 1 / (1 + exp(-Z %*% gammas + V))#
  Sigma.b = 10 * p1 * diag(p1)#
  Sigma.g = 10 * p2 * diag(p2)#
  betas.samp = matrix(NA, nrow = (N - burn) / thin, ncol = p1)#
  gammas.samp = matrix(NA, nrow = (N - burn) / thin, ncol = p2)#
  rho.samp = rep(NA, (N - burn) / thin)
burn = 0
p1 = dim(X)[2]#
  p2 = dim(Z)[2]#
  # initial values#
  betas = rep(0, p1)#
  gammas = rep(0, p2)#
  rho = 1#
  lambda = 1#
  W = rep(0, length(Y))#
  V = rep(0, length(Y))#
  delta = 1 / (1 + exp(-Z %*% gammas + V))#
  Sigma.b = 10 * p1 * diag(p1)#
  Sigma.g = 10 * p2 * diag(p2)#
  betas.samp = matrix(NA, nrow = (N - burn) / thin, ncol = p1)#
  gammas.samp = matrix(NA, nrow = (N - burn) / thin, ncol = p2)#
  rho.samp = rep(NA, (N - burn) / thin)
thin = 1
p1 = dim(X)[2]#
  p2 = dim(Z)[2]#
  # initial values#
  betas = rep(0, p1)#
  gammas = rep(0, p2)#
  rho = 1#
  lambda = 1#
  W = rep(0, length(Y))#
  V = rep(0, length(Y))#
  delta = 1 / (1 + exp(-Z %*% gammas + V))#
  Sigma.b = 10 * p1 * diag(p1)#
  Sigma.g = 10 * p2 * diag(p2)#
  betas.samp = matrix(NA, nrow = (N - burn) / thin, ncol = p1)#
  gammas.samp = matrix(NA, nrow = (N - burn) / thin, ncol = p2)#
  rho.samp = rep(NA, (N - burn) / thin)
p1 = dim(X)[2]#
  p2 = dim(Z)[2]#
  # initial values
betas = rep(0, p1)#
  gammas = rep(0, p2)#
  rho = 1#
  lambda = 1#
  W = rep(0, length(Y))#
  V = rep(0, length(Y))
Y
X = sample(1:10, 1000, TRUE)
Z = X
Y = sample(1:100, 1000, TRUE)
Y
betas = rep(0, p1)#
  gammas = rep(0, p2)#
  rho = 1#
  lambda = 1#
  W = rep(0, length(Y))#
  V = rep(0, length(Y))
p1 = dim(X)[2]#
  p2 = dim(Z)[2]#
  # initial values#
  betas = rep(0, p1)#
  gammas = rep(0, p2)#
  rho = 1#
  lambda = 1#
  W = rep(0, length(Y))#
  V = rep(0, length(Y))
p1
X = rbind(rep(1, 1000), X)
X
X = t(X)
X
Z = X
p1 = dim(X)[2]#
  p2 = dim(Z)[2]#
  # initial values#
  betas = rep(0, p1)#
  gammas = rep(0, p2)#
  rho = 1#
  lambda = 1#
  W = rep(0, length(Y))#
  V = rep(0, length(Y))
delta = 1 / (1 + exp(-Z %*% gammas + V))#
  Sigma.b = 10 * p1 * diag(p1)#
  Sigma.g = 10 * p2 * diag(p2)#
  betas.samp = matrix(NA, nrow = (N - burn) / thin, ncol = p1)#
  gammas.samp = matrix(NA, nrow = (N - burn) / thin, ncol = p2)#
  rho.samp = rep(NA, (N - burn) / thin)#
  lambda.samp = rep(NA, (N - burn) / thin)#
  W.samp = matrix(NA, nrow = (N - burn) / thin, ncol = length(Y))#
  V.samp = matrix(NA, nrow = (N - burn) / thin, ncol = length(Y))
delta
iter
iter = 1
Sigma.b = riwish(1 + p1, betas %*% t(betas) + p1 * diag(p1))
library(MCMCpack)
Sigma.b = riwish(1 + p1, betas %*% t(betas) + p1 * diag(p1))
Sigma.b
Sigma.g = riwish(1 + p2, gammas %*% t(gammas) + p2 * diag(p2))
Sigma.g
lambda = lambda.gibbs.sampling(S, A, W, V)
S = sample(1:5, 1000, TRUE)
A
S
A = matrix(1, 1000, 1000)
A
diag(A) = 0
lambda = lambda.gibbs.sampling(S, A, W, V)
lambda
which(A[i,]==1)
lambda.gibbs.sampling <- function(S, A, W, V, a = 1, b = 1) {#
  Ns = length(S)#
  sums = 0#
  for (i in 1:Ns) {#
    adj = S %in% which(A[i,]==1)#
    m_i = sum(adj)#
    W_i_bar = mean(W[adj])#
    V_i_bar = mean(V[adj])#
    sums = sums + m_i/2 * ((W[i]-W_i_bar)^2 + (V[i]-V_i_bar)^2)#
  }#
  lambda = rgamma(1, Ns + a, sums + b)#
  return(lambda)#
}
lambda = lambda.gibbs.sampling(S, A, W, V)
lambda
S %in% which(A[i,]==1)
i = 10
S %in% which(A[i,]==1)
which(A[i,]==1)
S %in% which(A[i,]==1)
adj = S %in% which(A[i,]==1)#
    m_i = sum(adj)
m_i
adj = which(A[i,]==1)
adj
m_i = length(adj)
m_i
mean(W[adj])
mean(V[adj])
m_i/2 * ((W[i]-W_i_bar)^2 + (V[i]-V_i_bar)^2)
W_i_bar = mean(W[adj])#
    V_i_bar = mean(V[adj])
m_i/2 * ((W[i]-W_i_bar)^2 + (V[i]-V_i_bar)^2)
Ns = length(S)#
  sums = 0#
  for (i in 1:Ns) {#
    adj = which(A[i,]==1)#
    m_i = length(adj)#
    W_i_bar = mean(W[adj])#
    V_i_bar = mean(V[adj])#
    sums = sums + m_i/2 * ((W[i]-W_i_bar)^2 + (V[i]-V_i_bar)^2)#
  }
sums
rgamma(1, Ns + a, sums + b)
lambda = lambda.gibbs.sampling(S, A, W, V)
lambda
W = W.slice.sampling(S, A, lambda, Y, X, W, betas, delta, C, rho, w[1], m, form = form)
betas = betas.slice.sampling(Sigma.b, Y, X, W, betas, delta, C, rho, w[1], m, form = form)
eXB = exp(X %*% betas + W)
eXB
document()
check()
document()
check()
document()
check()
document()
check()
document()
check()
rgamma
?rgamma
document()
check()
document()
check()
document()
check()
?dnorm
document9
documnet()
document()
check()
A
document()
check()
document()
check()
document()
check()
document()
check()
install()
mcmcSpatialCure
?mcmcSpatialCure
?mcmcCure
??mcmcCure
document()
library(devtools)
document()
check()
document()
check()
?mcmcSurv
??mcmcSurv
document9
documnet()
document()
check()
install()
1 / (1 + exp(-Inf))
document()
check()
document()
check()
install()
###########################################################################
#set seed#
set.seed(3)   #
#set the number of observations#
n<-1000#
#set the number of simulations, and create matrices to store the results#
#nsims<-1000#
nsims<-1000#
#history matrix for true estimates#
tru.est<-matrix(NA,nrow=nsims,ncol=8)#
#history matrix for cox estimates#
cox.est<-matrix(NA,nrow=nsims,ncol=2)#
#history matrix for exp estimates#
exp.est<-matrix(NA,nrow=nsims,ncol=14)#
#history matrix for weibull estimates#
weib.est<-matrix(NA,nrow=nsims,ncol=18)#
#history matrix for cox RMSE#
cox.rmse<-matrix(NA,nrow=nsims,ncol=1)#
#history matrix for exp RMSE#
exp.rmse<-matrix(NA,nrow=nsims,ncol=7)#
#history matrix for exp RMSE#
weib.rmse<-matrix(NA,nrow=nsims,ncol=9)#
#history matrix for cox CP#
cox.cp<-matrix(NA,nrow=nsims,ncol=1)#
#history matrix for exp CP#
exp.cp<-matrix(NA,nrow=nsims,ncol=7)#
#history matrix for exp CP#
weib.cp<-matrix(NA,nrow=nsims,ncol=9)#
#create covariates#
x<-runif(n, min=-2.5, max=12)#
z<-log(runif(n, min=1, max=100))#
#create lat and lon from uniformly distributed variable#
lat<-runif(n,-4,4)#
lon<-runif(n,-4,4)#
#create a dependent variable, begin the simmulations#
for(i in 1:nsims){#
#Assign parameter values#
tru.est[i,1]<-1#
tru.est[i,2]<-3.5#
tru.est[i,3]<--2#
tru.est[i,4]<--2#
tru.est[i,5]<-3#
tru.est[i,6]<-1#
#simmulate the non-cure survival variable#
#Note that Iíve included latitude in the model to induce a spatial correlation structure.#
myrates <- exp(tru.est[i,1]+(tru.est[i,2]*x-2*lat)) #
y <- rexp(n, rate = myrates) # generates the r.v.#
cen <- rexp(n, rate = 1 )#
ycen <- pmin(y, cen)#
di <- as.numeric(y <= cen)#
tru.est[i,7]<-table(di)[1]#
#add in the cure population#
#create parameters for ZG (Note that Iíve included latitude in the model to induce a spatial correlation structure)#
phi<-1/(1+exp(-(tru.est[i,3]+tru.est[i,4]*z+tru.est[i,5]*x-2*lat)))#
yzero<-matrix(0,n,1)#
error<--1*rlogis(n)#
flag<-error>qlogis(phi)#
yzero[flag]<-error[flag]#
flag<-yzero==0#
ycen[flag]<-ifelse(di[flag]==1,cen[flag],ycen[flag])#
di[flag]<-ifelse(di[flag]==1,yzero[flag],di[flag])#
tru.est[i,8]<-table(di)[1]#
data<-cbind(ycen,di,x,z,lat,lon)
i = 1
library(foreign)#
library(car)#
library(MASS)#
library(VGAM)#
library(survival)#
library(msm)#
library(verification)#
library(corpcor)#
library(Design)
#set the number of observations#
n<-1000#
#set the number of simulations, and create matrices to store the results#
#nsims<-1000#
nsims<-1000#
#history matrix for true estimates#
tru.est<-matrix(NA,nrow=nsims,ncol=8)#
#history matrix for cox estimates#
cox.est<-matrix(NA,nrow=nsims,ncol=2)#
#history matrix for exp estimates#
exp.est<-matrix(NA,nrow=nsims,ncol=14)#
#history matrix for weibull estimates#
weib.est<-matrix(NA,nrow=nsims,ncol=18)#
#history matrix for cox RMSE#
cox.rmse<-matrix(NA,nrow=nsims,ncol=1)#
#history matrix for exp RMSE#
exp.rmse<-matrix(NA,nrow=nsims,ncol=7)#
#history matrix for exp RMSE#
weib.rmse<-matrix(NA,nrow=nsims,ncol=9)#
#history matrix for cox CP#
cox.cp<-matrix(NA,nrow=nsims,ncol=1)#
#history matrix for exp CP#
exp.cp<-matrix(NA,nrow=nsims,ncol=7)#
#history matrix for exp CP#
weib.cp<-matrix(NA,nrow=nsims,ncol=9)#
#create covariates#
x<-runif(n, min=-2.5, max=12)#
z<-log(runif(n, min=1, max=100))#
#create lat and lon from uniformly distributed variable#
lat<-runif(n,-4,4)#
lon<-runif(n,-4,4)
i
#Assign parameter values#
tru.est[i,1]<-1#
tru.est[i,2]<-3.5#
tru.est[i,3]<--2#
tru.est[i,4]<--2#
tru.est[i,5]<-3#
tru.est[i,6]<-1#
#simmulate the non-cure survival variable#
#Note that Iíve included latitude in the model to induce a spatial correlation structure.#
myrates <- exp(tru.est[i,1]+(tru.est[i,2]*x-2*lat)) #
y <- rexp(n, rate = myrates) # generates the r.v.#
cen <- rexp(n, rate = 1 )#
ycen <- pmin(y, cen)#
di <- as.numeric(y <= cen)#
tru.est[i,7]<-table(di)[1]#
#add in the cure population#
#create parameters for ZG (Note that Iíve included latitude in the model to induce a spatial correlation structure)#
phi<-1/(1+exp(-(tru.est[i,3]+tru.est[i,4]*z+tru.est[i,5]*x-2*lat)))#
yzero<-matrix(0,n,1)#
error<--1*rlogis(n)#
flag<-error>qlogis(phi)#
yzero[flag]<-error[flag]#
flag<-yzero==0#
ycen[flag]<-ifelse(di[flag]==1,cen[flag],ycen[flag])#
di[flag]<-ifelse(di[flag]==1,yzero[flag],di[flag])#
tru.est[i,8]<-table(di)[1]#
data<-cbind(ycen,di,x,z,lat,lon)
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)
mcmcSurv
mcmcSurv(Y, C, X, X, 1500, 500)
mcmcSurv(Y, C, X, X, 1500, 500, 1, form = "Weibull")
p1 = dim(X)[2]#
  p2 = dim(Z)[2]#
  # initial values#
  betas = rep(0, p1)#
  gammas = rep(Inf, p2)#
  rho = 1#
  W = rep(0, length(Y))#
  delta = 1 / (1 + exp(-Z %*% gammas))#
  Sigma.b = 10 * p1 * diag(p1)#
  betas.samp = matrix(NA, nrow = (N - burn) / thin, ncol = p1)#
  rho.samp = rep(NA, (N - burn) / thin)
N = 10
p1 = dim(X)[2]#
  p2 = dim(Z)[2]#
  # initial values#
  betas = rep(0, p1)#
  gammas = rep(Inf, p2)#
  rho = 1#
  W = rep(0, length(Y))#
  delta = 1 / (1 + exp(-Z %*% gammas))#
  Sigma.b = 10 * p1 * diag(p1)#
  betas.samp = matrix(NA, nrow = (N - burn) / thin, ncol = p1)#
  rho.samp = rep(NA, (N - burn) / thin)
Z
Z = X
p1 = dim(X)[2]#
  p2 = dim(Z)[2]#
  # initial values#
  betas = rep(0, p1)#
  gammas = rep(Inf, p2)#
  rho = 1#
  W = rep(0, length(Y))#
  delta = 1 / (1 + exp(-Z %*% gammas))#
  Sigma.b = 10 * p1 * diag(p1)#
  betas.samp = matrix(NA, nrow = (N - burn) / thin, ncol = p1)#
  rho.samp = rep(NA, (N - burn) / thin)
burn = 0
p1 = dim(X)[2]#
  p2 = dim(Z)[2]#
  # initial values#
  betas = rep(0, p1)#
  gammas = rep(Inf, p2)#
  rho = 1#
  W = rep(0, length(Y))#
  delta = 1 / (1 + exp(-Z %*% gammas))#
  Sigma.b = 10 * p1 * diag(p1)#
  betas.samp = matrix(NA, nrow = (N - burn) / thin, ncol = p1)#
  rho.samp = rep(NA, (N - burn) / thin)
thin = 1
p1 = dim(X)[2]#
  p2 = dim(Z)[2]#
  # initial values#
  betas = rep(0, p1)#
  gammas = rep(Inf, p2)#
  rho = 1#
  W = rep(0, length(Y))#
  delta = 1 / (1 + exp(-Z %*% gammas))#
  Sigma.b = 10 * p1 * diag(p1)#
  betas.samp = matrix(NA, nrow = (N - burn) / thin, ncol = p1)#
  rho.samp = rep(NA, (N - burn) / thin)
Sigma.b = riwish(1 + p1, betas %*% t(betas) + p1 * diag(p1))
library(MCMCpack)
Sigma.b = riwish(1 + p1, betas %*% t(betas) + p1 * diag(p1))
Sigma.b
betas = betas.slice.sampling(Sigma.b, Y, X, W, betas, delta, C, rho, w[1], m, form = form)
w = c(1, 1, 1)
betas = betas.slice.sampling(Sigma.b, Y, X, W, betas, delta, C, rho, w[1], m, form = form)
m = 10
betas = betas.slice.sampling(Sigma.b, Y, X, W, betas, delta, C, rho, w[1], m, form = form)
form
form = "Weibull"
betas = betas.slice.sampling(Sigma.b, Y, X, W, betas, delta, C, rho, w[1], m, form = form)
eXB = exp(X %*% betas + W)
eXB
lprior = dmvnorm(betas, rep(0, length(betas)), Sigma.b, log = TRUE)
library(mvtnorm)
lprior = dmvnorm(betas, rep(0, length(betas)), Sigma.b, log = TRUE)
lprior
lpost = llikWeibull(Y, eXB, delta, C, rho) + lprior
Y
eXB
C
delta
document()
check()
document()
check()
install()
mcmcSurv(Y, C, X, X, 1500, 500, 1, form = "Weibull")
mcmcSurv(Y, C, X, 1500, 500, 1, form = "Weibull")
#Assign parameter values#
tru.est[i,1]<-1#
tru.est[i,2]<-3.5#
tru.est[i,3]<--2#
tru.est[i,4]<--2#
tru.est[i,5]<-3#
tru.est[i,6]<-1#
#simmulate the non-cure survival variable#
#Note that Iíve included latitude in the model to induce a spatial correlation structure.#
myrates <- exp(tru.est[i,1]+(tru.est[i,2]*x))#
y <- rexp(n, rate = myrates) # generates the r.v.#
cen <- rexp(n, rate = 1 )#
ycen <- pmin(y, cen)#
di <- as.numeric(y <= cen)#
tru.est[i,7]<-table(di)[1]#
#add in the cure population#
#create parameters for ZG (Note that Iíve included latitude in the model to induce a spatial correlation structure)#
phi<-1/(1+exp(-(tru.est[i,3]+tru.est[i,4]*z+tru.est[i,5]*x-2*lat)))#
yzero<-matrix(0,n,1)#
error<--1*rlogis(n)#
flag<-error>qlogis(phi)#
yzero[flag]<-error[flag]#
flag<-yzero==0#
ycen[flag]<-ifelse(di[flag]==1,cen[flag],ycen[flag])#
di[flag]<-ifelse(di[flag]==1,yzero[flag],di[flag])#
tru.est[i,8]<-table(di)[1]#
data<-cbind(ycen,di,x,z,lat,lon)
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)
mcmcSurv(Y, C, X, 1500, 500, 1, form = "Weibull")
#Assign parameter values#
tru.est[i,1]<-1#
tru.est[i,2]<-3.5#
tru.est[i,3]<--2#
tru.est[i,4]<--2#
tru.est[i,5]<-3#
tru.est[i,6]<-1#
#simmulate the non-cure survival variable#
#Note that Iíve included latitude in the model to induce a spatial correlation structure.#
myrates <- exp(tru.est[i,1]+(tru.est[i,2]*x))#
y <- rexp(n, rate = myrates) # generates the r.v.#
cen <- rexp(n, rate = 1 )#
ycen <- pmin(y, cen)#
di <- as.numeric(y <= cen)#
tru.est[i,7]<-table(di)[1]
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)
mcmcSurv(Y, C, X, 1500, 500, 1, form = "Weibull")
library(devtools)
document()
check()
install()
library(SpatialCure)
#load necessary libraries 						                                 #
library(foreign)#
library(car)#
library(MASS)#
library(VGAM)#
library(survival)#
library(msm)#
library(verification)#
library(corpcor)#
library(Design)
#set the number of observations#
n<-1000#
#set the number of simulations, and create matrices to store the results#
#nsims<-1000#
nsims<-1000#
#history matrix for true estimates#
tru.est<-matrix(NA,nrow=nsims,ncol=8)#
#history matrix for cox estimates#
cox.est<-matrix(NA,nrow=nsims,ncol=2)#
#history matrix for exp estimates#
exp.est<-matrix(NA,nrow=nsims,ncol=14)#
#history matrix for weibull estimates#
weib.est<-matrix(NA,nrow=nsims,ncol=18)#
#history matrix for cox RMSE#
cox.rmse<-matrix(NA,nrow=nsims,ncol=1)#
#history matrix for exp RMSE#
exp.rmse<-matrix(NA,nrow=nsims,ncol=7)#
#history matrix for exp RMSE#
weib.rmse<-matrix(NA,nrow=nsims,ncol=9)#
#history matrix for cox CP#
cox.cp<-matrix(NA,nrow=nsims,ncol=1)#
#history matrix for exp CP#
exp.cp<-matrix(NA,nrow=nsims,ncol=7)#
#history matrix for exp CP#
weib.cp<-matrix(NA,nrow=nsims,ncol=9)#
#create covariates#
x<-runif(n, min=-2.5, max=12)#
z<-log(runif(n, min=1, max=100))
i
i = 1
#Assign parameter values#
tru.est[i,1]<-1#
tru.est[i,2]<-3.5#
tru.est[i,3]<--2#
tru.est[i,4]<--2#
tru.est[i,5]<-3#
tru.est[i,6]<-1#
myrates <- exp(tru.est[i,1]+(tru.est[i,2]*x)) #
y <- rexp(n, rate = myrates) # generates the r.v.#
cen <- rexp(n, rate = 1 )#
ycen <- pmin(y, cen)#
di <- as.numeric(y <= cen)#
tru.est[i,7]<-table(di)[1]#
#create parameters for ZG#
phi<-1/(1+exp(-(tru.est[i,3]+tru.est[i,4]*z+tru.est[i,5]*x)))#
yzero<-matrix(0,n,1)#
error<--1*rlogis(n)#
flag<-error>qlogis(phi)#
yzero[flag]<-error[flag]#
flag<-yzero==0#
ycen[flag]<-ifelse(di[flag]==1,cen[flag],ycen[flag])#
di[flag]<-ifelse(di[flag]==1,yzero[flag],di[flag])#
tru.est[i,8]<-table(di)[1]#
data<-cbind(ycen,di,x,z)
#set data, Y and X#
data<-data#
Y<-ycen#
C<-di#
X<-cbind(1,x)#
Z<-cbind(1,z,x)
mcmcCure(Y, C, X, Z, 1500, 500, 1, form = "Weibull")
hey = mcmcCure(Y, C, X, Z, 6500, 1500, 5, form = "Weibull")
names(hey)
colMeans(hey$gammas)
hey$gammas
mcmcSpatialSurv
mcmcSpatialSurv
mcmcSpatSurv
mcmcSpatCure
mcmcSpatialCure
sample(1:5, 1000, replace = TRUE)
