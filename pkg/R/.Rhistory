document()
library(devtools)
document()
check()
document()
check()
document()
check()
document()
check()
install()
x<-runif(n, min=-2.5, max=12)
#clear memory
rm( list=ls() )
#load necessary libraries
library(foreign)
library(car)
library(MASS)
library(VGAM)
library(survival)
library(msm)
library(verification)
library(corpcor)
library(Design)
#set working directory
setwd("/Users/bomin8319/Desktop/SpatialCureSurv/simulation")
##########################################################################
##########################################################################
############################Monte Carlo###################################
##########################################################################
#set seed
set.seed(3)
#set the number of observations
n<-1000
#set the number of simulations, and create matrices to store the results
#nsims<-1000
nsims<-1000
#history matrix for true estimates
tru.est<-matrix(NA,nrow=nsims,ncol=8)
#history matrix for cox estimates
cox.est<-matrix(NA,nrow=nsims,ncol=2)
#history matrix for exp estimates
exp.est<-matrix(NA,nrow=nsims,ncol=14)
#history matrix for weibull estimates
weib.est<-matrix(NA,nrow=nsims,ncol=18)
#history matrix for cox RMSE
cox.rmse<-matrix(NA,nrow=nsims,ncol=1)
#history matrix for exp RMSE
exp.rmse<-matrix(NA,nrow=nsims,ncol=7)
#history matrix for exp RMSE
weib.rmse<-matrix(NA,nrow=nsims,ncol=9)
#history matrix for cox CP
cox.cp<-matrix(NA,nrow=nsims,ncol=1)
#history matrix for exp CP
exp.cp<-matrix(NA,nrow=nsims,ncol=7)
#history matrix for exp CP
weib.cp<-matrix(NA,nrow=nsims,ncol=9)
#create covariates
x<-runif(n, min=-2.5, max=12)
d
x
tru.est[i,7]<-1
load('/Users/bomin8319/Library/Containers/com.apple.mail/Data/Library/Mail Downloads/7B46BBAF-3584-4C2B-B3AC-072B26313683/Crabtree, Darmofal & Kern 2015 replication/Modeling data 2.RData')
hey = load('/Users/bomin8319/Library/Containers/com.apple.mail/Data/Library/Mail Downloads/7B46BBAF-3584-4C2B-B3AC-072B26313683/Crabtree, Darmofal & Kern 2015 replication/Modeling data 2.RData')
hey
head(hey$protests)
head(protests)
adjacency
dim(adjacency)
length(unique(protest$county))
length(unique(protests$county))
length(unique(protests$county))
library(devtools)
document(
)
setwd('/Users/bomin8319/Desktop/SpatialCureSurv/pkg/R')
document()
check()
A = matrix(rbinom(100, 0.5), 10, 10)
A = matrix(rbinom(100, 1, 0.5), 10, 10)
A
diag(A)=0
A
A = (A+t(A))/2
A
A = (A>0)
A
A = as.numeric(A)
A
A = matrix(rbinom(100, 1, 0.5), 10, 10)
A
diag(A)= 0
A
A = t(A)+A
A
A = t(A)+A/2
A
A = A/3
A
A = A[A>0]
A
A = matrix(rbinom(100, 1, 0.2), 10, 10)
A
diag(A) = 0
A = (A + t(A))/2
A
A = as.matrix(A>0)
A
A = as.matrix(as.numeric(A))
A
A = matrix(rbinom(100, 1, 0.2), 10, 10)
A
A  matrix(rbinom(100, 1, 0.2), 10, 10)
A = matrix(rbinom(100, 1, 0.2), 10, 10)
A
diag(A)=0
A
A = (A + t(A));2
A = (A + t(A))/2
A
A[which(A==2)] = 1
A
is.symmetric(A
)
sum(A[1,])
sample
S = sample(100, 10, replace = TRUE)
S
S = sample(1:10, 100, replace = TRUE)
S
length(unique(S))
sum(A[1,])
i
i= 1
S[i]
sum(A[S[i],])
A[7,]
sum(S %in% which(A[S[i],]==1))
which(A[S[i],]==1)
sum(S %in% which(A[S[i],]==1))
S
S %in% which(A[S[i],]==1)
mean(W[S %in% which(A[S[i],]==1)])
mean(S[S %in% which(A[S[i],]==1)])
adj = S %in% which(A[S[i],]==1)
adj
m_i = sum(adj)
m_i
mean(W[adj])
mean(S[adj])
lambda.gibbs.sampling(S, A, W, V, a = 0.001, b = 1000) {
Ns = length(S)
sums = 0
for (i in 1:Ns) {
adj = S %in% which(A[S[i],]==1)
m_i = sum(adj)
W_i_bar = mean(W[adj])
V_i_bar = mean(V[adj])
sums = sums + m_i/2 * ((W[i]-W_i_bar)^2 + (V[i]-V_i_bar)^2)
}
lambda = rgamma(1, Ns + a, sums + b)
return(lambda)
}
lambda.gibbs.sampling <- function(S, A, W, V, a = 0.001, b = 1000) {
Ns = length(S)
sums = 0
for (i in 1:Ns) {
adj = S %in% which(A[S[i],]==1)
m_i = sum(adj)
W_i_bar = mean(W[adj])
V_i_bar = mean(V[adj])
sums = sums + m_i/2 * ((W[i]-W_i_bar)^2 + (V[i]-V_i_bar)^2)
}
lambda = rgamma(1, Ns + a, sums + b)
return(lambda)
}
lambda.gibbs.sampling(S, A, S, S)
lambda.gibbs.sampling(S, A, S, S)
lambda.gibbs.sampling(S, A, S, S)
W = S
Ns = length(S)
sums = 0
for (i in 1:Ns) {
adj = S %in% which(A[S[i],]==1)
m_i = sum(adj)
W_i_bar = mean(W[adj])
V_i_bar = mean(V[adj])
sums = sums + m_i/2 * ((W[i]-W_i_bar)^2 + (V[i]-V_i_bar)^2)
}
V = S
Ns = length(S)
Ns
sums = 0
for (i in 1:Ns) {
adj = S %in% which(A[S[i],]==1)
m_i = sum(adj)
W_i_bar = mean(W[adj])
V_i_bar = mean(V[adj])
sums = sums + m_i/2 * ((W[i]-W_i_bar)^2 + (V[i]-V_i_bar)^2)
}
sums
W_i_bar
V_i_bar
adj
m_i
W[i]
Ns + a
a
a = 0.001
b = 1000
rgamma(1, Ns + a, sums + b)
Ns + a
sums + b
lambda.gibbs.sampling <- function(S, A, W, V, a = 1, b = 1) {
Ns = length(S)
sums = 0
for (i in 1:Ns) {
adj = S %in% which(A[S[i],]==1)
m_i = sum(adj)
W_i_bar = mean(W[adj])
V_i_bar = mean(V[adj])
sums = sums + m_i/2 * ((W[i]-W_i_bar)^2 + (V[i]-V_i_bar)^2)
}
lambda = rgamma(1, Ns + a, sums + b)
return(lambda)
}
lambda.gibbs.sampling(S, A, S, S)
lambda.gibbs.sampling(S, A, S, S)
lambda.gibbs.sampling(S, A, S, S)
lambda.gibbs.sampling(S, A, S, S)
lambda.gibbs.sampling(S, A, S, S)
document()
document()
check()
install()
